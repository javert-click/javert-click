proc JSILMap_create(){
    ret := {{ }};
    return
};

proc JSILMap_add(map, key, value){
    keyl := {{ "Key", key }};
    vall := {{ "Value", value }};
    keyval := {{ keyl, vall }};
    map := map l+ {{ keyval }};
    ret := map;
    return
};

proc JSILMap_find(map, key){
                  i := 0;
                  len := l-len (map);
    loop:         goto [i < len] search end;
    search:       kvpair := l-nth (map, i);
                  keyl := l-nth (kvpair, 0);
                  keyv := l-nth (keyl, 1);
                  goto [keyv = key] found nf;
    found:        vall := l-nth(kvpair, 1);
                  ret := l-nth (vall, 1);
                  return;
    nf:           i := i+1;
                  goto loop;
    end:          ret := null;
                  return

};

proc JSILMap_add_or_replace(map, key, value){
                  i := 0;
                  len := l-len (map);
                  res := {{ }};
                  reskeyl := {{ "Key", key }};
                  resvall := {{ "Value", value }};
                  keyval := {{ reskeyl, resvall }};
                  found := false;
    loop:         goto [i < len] search add;
    search:       kvpair := l-nth (map, i);
                  keyl := l-nth (kvpair, 0);
                  keyv := l-nth (keyl, 1);
                  equality := keyv = key;
                  goto [keyv = key] foundkey nf;
    foundkey:     found := true;
                  res := res l+ {{ keyval }};
                  i := i+1;
                  goto loop;
    nf:           res := res l+ {{ kvpair }};
                  i := i+1;
                  goto loop;
    add:          goto [found = true] end makeadd;
    makeadd:      res := res l+ {{ keyval }};
                  goto end;
    end:          ret := res;
                  return

};

(***************************)
(******SERIALIZATION********)
(***************************)

proc SerializeErrorObj (xsc, vthis, value){
                  (* 17.1 Let name be ? Get(value, "name").  *)
                  name := "get" (value, "name") with elab;
                  (* 17.2 If name is not one of "Error", "EvalError", "RangeError", "ReferenceError", "SyntaxError", *)
                    (* "TypeError", or "URIError", then set name to "Error". *)
                  goto [(name = "Error") or (name = "EvalError") or (name = "RangeError") or (name = "ReferenceError") or (name = "SyntaxError") or (name = "TypeError") or (name = "URIError")] cont namenotinsub;
    namenotinsub: name := "Error";
                  goto cont;
    cont:         (* 17.3 Let valueMessageDesc be ? value.[[GetOwnProperty]]("message"). *)
                  valueMessageDesc := "getOwnProperty" (value, "message") with elab;
                  (* 17.4 Let message be undefined if IsDataDescriptor(valueMessageDesc) is false, and ? ToString(valueMessageDesc.[[Value]]) otherwise. *)
                  isdatadesc := "i__isDataDescriptor" (valueMessageDesc);
                  goto [isdatadesc = true] dd nondd;
    dd:           mv := l-nth (valueMessageDesc, 1);
                  message := "i__toString" (mv) with elab;
                  goto errorobjret;
    nondd:        message := undefined;
                  goto errorobjret;
    errorobjret:  (* 17.5 Set serialized to { [[Type]]: "Error", [[Name]]: name, [[Message]]: message }. *)
                  type := {{ "Type", "Error" }};
                  name := {{ "Name", name }}; 
                  message := {{ "Message", message }};
                  serialized := {{ type, name, message }};
                  (* 17.6 (NOT SUPPORTEF) User agents should attach a serialized representation of any interesting accompanying data *)
                   (* which are not yet specified, notably the stack property, to serialized. *)
                  ret := serialized;
                  return;
    elab:         throw
};

(* Auxiliary function used to serialize object with primitive val. Example: 
    Num n:    {{ "Type": "Number", "NumberData": n }} 
    String s: {{ "Type": "String", "StringData": s }} 
*)
proc SerializeObjectWithPrimVal (xsc, vthis, value){
                  (* 6. Let serialized be an uninitialized value. *)
                  serialized := undefined;
                  m := metadata(value);
			      clazz := [m, "@class"];
                  (* 7. If value has a [[BooleanData]] internal slot, *)
                   (* then set serialized to { [[Type]]: "Boolean", [[BooleanData]]: value.[[BooleanData]] }. *)
			      goto [clazz = "Boolean"] boolobj nonboolobj;  
    boolobj:      type := {{ "Type", "Boolean" }};
                  booldata := "BP_valueOf" (xsc, value);
                  booldatal := {{ "BooleanData", booldata }};
                  serialized := {{ type, booldatal }};
                  goto succ;
    nonboolobj:   (* 8. Otherwise, if value has a [[NumberData]] internal slot, *)
                   (* then set serialized to { [[Type]]: "Number", [[NumberData]]: value.[[NumberData]] }. *)
                  goto [(clazz = "Number")] numobj nonnumobj;
    numobj:       type := {{ "Type", "Number" }};
                  numdata := "NP_valueOf" (xsc, value);
                  numdatal := {{ "NumberData", numdata }};
                  serialized := {{ type, numdatal }};
                  goto succ;
    nonnumobj:    (* 9. (NOT SUPPORTED) Otherwise, if value has a [[BigIntData]] internal slot, 
                   (* then set serialized to { [[Type]]: "BigInt", [[BigIntData]]: value.[[BigIntData]] }. *)
                  (* 10. Otherwise, if value has a [[StringData]] internal slot, *)
                   (* then set serialized to { [[Type]]: "String", [[StringData]]: value.[[StringData]] }. *)
                  goto [(clazz = "String")] strobj nonstrobj;
    strobj:       type := {{ "Type", "String" }};
                  strdata := "SP_valueOf" (xsc, value);
                  strdatal := {{ "StringData", strdata }};
                  serialized := {{ type, strdatal }};
                  goto succ;  
    nonstrobj:    (* 11. Otherwise, if value has a [[DateValue]] internal slot, *)
                   (* then set serialized to { [[Type]]: "Date", [[DateValue]]: value.[[DateValue]] }. *)
                  goto [(clazz = "Date")] dateobj nondateobj;
    dateobj:      type := {{ "Type", "Date" }};
                  datedata := "DP_valueOf" (xsc, value);
                  datedatal := {{ "DateValue", datedata }};
                  serialized := {{ type, datedatal }};
                  goto succ;
    nondateobj:   (* 12. (NOT SUPPORTED) Otherwise, if value has a [[RegExpMatcher]] internal slot, then set serialized to ... . *)
                  (* 13. (NOT SUPPORTED) Otherwise, if value has an [[ArrayBufferData]] internal slot, then: *)
                  (* 14. (NOT SUPPORTED) Otherwise, if value has a [[ViewedArrayBuffer]] internal slot, then: *)
                  (* 15. (NOT SUPPORTED) Otherwise, if value has [[MapData]] internal slot, then: *)
                  (* 16. (NOT SUPPORTED) Otherwise, if value has [[SetData]] internal slot, then: *)
                  (* 17. Otherwise, if value has an [[ErrorData]] internal slot and value is not a platform object, then: *)
                  goto [(clazz = "Error")] errorobj succ;
                  (* Step 17 is implemented in SerializeErrorObj (defined above) *)
    errorobj:     serialized := "SerializeErrorObj" (xsc, vthis, value);
                  (* 18. Otherwise, if value is an Array exotic object, then: *)
    succ:         ret := serialized;
                  return
};

proc SerializeObject(xsc, vthis, value, forStorage, memory, datacloneerr, typestr){
                  type := {{ "Type", typestr }};
                  properties := "JSILMap_create" ();
                  (* 26.4 Otherwise, for each key in ! EnumerableOwnPropertyNames(value, key): *)
                  serialized := {{ }};
                  keys := "i__getEnumerableFields" (value);
                  keyvals := {{ }};
                  i := 0;
                  n := l-len (keys);
                  goto [n = 0] noelems loop;
    noelems:      count := l-len(memory);
                  countlist := {{ "Id", count }};
                  properties := {{ }};
                  propslist := {{ "Properties", properties }};
                  lengthl := {{ "Length", 0 }};
                  serialized := {{ type, propslist, countlist, lengthl }};
                  memory := "JSILMap_add_or_replace" (memory, value, serialized);
                  goto succ;
    loop:         goto [i < n] addprop succ;
    addprop:      key := l-nth (keys, i);
                  (* 26.4.1 If ! HasOwnProperty(value, key) is true, then:*)
                  hasprop := "OP_hasOwnProperty" (undefined, value, key);
                  goto [hasprop = true] propfound propnf;
                  (* 26.4.1.1 Let inputValue be ? value.[[Get]](key, value). *)
    propfound:    inputVal := "get" (value, key) with eget;
                  (* 26.4.1.2 Let outputValue be ? StructuredSerializeInternal(inputValue, forStorage, memory). *)
                  outputValue := "StructuredSerializeInternalWithMemory" (xsc, vthis, inputVal, forStorage, memory, datacloneerr)with elab;
                  outputSerialized := [outputValue, "serialized"];
                  outputMemory := [outputValue, "memory"];
                  (* 26.4.1.3 Append { [[Key]]: key, [[Value]]: outputValue } to serialized.[[Properties]]. *)
                  properties := "JSILMap_add" (properties, key, outputSerialized);
                  propslist := {{ "Properties", properties }};
                  count := l-len(outputMemory);
                  countlist := {{ "Id", count }};
                  serialized := {{ type, propslist, countlist }};
                  outputMemory := "JSILMap_add_or_replace" (outputMemory, value, serialized);
                  memory := outputMemory;
                  i := i+1;   
                  goto loop;
    propnf:       i := i+1;
                  goto loop;  
    succ:         res := new ();
                  [res, "serialized"] := serialized;
                  [res, "memory"] := memory;
                  ret := res;
                  return;
    elab:         ret := outputValueSerialized;
                  throw; 
    eget:         ret := inputVal;  
                  throw              
};

proc StructuredSerializeInternalWithMemory(xsc, vthis, value, forStorage, memory, datacloneerr){
                  (* 2. If memory[value] exists, then return memory[value].*)
                  (*debugger;*)
                  cache := "JSILMap_find" (memory, value);
                  goto [cache = null] nullcache nonnullcache;
    nonnullcache: res := new ();
                  [res, "serialized"] := cache;
                  [res, "memory"] := memory;
                  ret := res;
                  return;
    nullcache:    (* 3. Let deep be false. *)
                  deep := false;
                  (* 4. If Type(value) is Undefined, Null, Boolean, Number, BigInt, or String, then return *)
                  (* { [[Type]]: "primitive", [[Value]]: value }. *)
                  tv := typeOf value;
                  goto [(value = undefined) or (value = null) or (tv = Bool) or (tv = Num) or (tv = Str)] basic notbasic;
	basic:        type := {{ "Type", "primitive"}};
                  val := {{ "Value", value}};
                  res := new ();
                  [res, "serialized"] := {{ type, val }};
                  [res, "memory"] := memory;
                  ret := res;
                  return;
    notbasic:     (* 5. (NOT SUPPORTED) If Type(value) is Symbol, then throw a "DataCloneError" DOMException.*)
                  goto [(tv = Obj)] tvobj elab;
                  (* Steps 6 - 11 are implemented in SerializeObjectWithPrimVal *)
    tvobj:        serialized := "SerializeObjectWithPrimVal" (xsc, vthis, value);
                  goto [serialized = undefined] nonerrorobj updatemem;
    nonerrorobj:  (* 18. Otherwise, if value is an Array exotic object, then:*)
                  m := metadata(value);
			      clazz := [m, "@class"];
                  goto [clazz = "Array"] arrobj nodataclone;
    arrobj:       (* 18.1. Let valueLenDescriptor be ? OrdinaryGetOwnProperty(value, "length"). *)
                  valueLenDescriptor := "getOwnProperty" (value, "length");
                  (* 18.2. Let valueLen be valueLenDescriptor.[[Value]]. *)
                  valueLen := l-nth (valueLenDescriptor, 1);
                  (* 18.3 Set serialized to { [[Type]]: "Array", [[Length]]: valueLen, [[Properties]]: a new empty List }. *)
                  serializedArrObj := "SerializeObject"(xsc, vthis, value, forStorage, memory, datacloneerr, "Array");
                  serialized := [serializedArrObj, "serialized"];
                  lengthl := {{ "Length", valueLen }};
                  serialized := serialized l+ {{ lengthl }};
                  objmem := [serializedArrObj, "memory"];
                  memory := objmem;
                  goto succ; 
                  (* 19. (NOT SUPPORTED) Otherwise, if value is a platform object that is a serializable object: *)
                  (* 20. (NOT SUPPORTED) Otherwise, if value is a platform object, then throw a "DataCloneError" DOMException. *)
                  (* 21. Otherwise, if IsCallable(value) is true, then throw a "DataCloneError" DOMException. *)
                  is_callable := "i__isCallable" (value);
                  goto [is_callable = true] dataclon nodataclone;
    dataclon:     ret := datacloneerr;
                  throw;
    nodataclone:  (* 22. Otherwise, if value has any internal slot other than [[Prototype]] or [[Extensible]], then throw a "DataCloneError" DOMException. *)
                  (* TODOMP *)
                  (* 23. (NOT SUPPORTED) Otherwise, if value is an exotic object ... *)
                  (* 24. Otherwise: *)
                  goto [clazz = "Object"] obj updatemem;
    obj:          (* 24.1 Set serialized to { [[Type]]: "Object", [[Properties]]: a new empty List }. *)
                  (* 24.2 Set deep to true. *)
                  deep := true;
                  goto updatemem;
    updatemem:    (* 25. Set memory[value] to serialized. *)
                  (* 26. If deep is true, then: *)
                  goto [deep = true] deep succ;           
    deep:         (* 26.1 (NOT SUPPORTED) If value has a [[MapData]] internal slot, then: *)
                  (* 26.2 (NOT SUPPORTED) Otherwise, if value has a [[SetData]] internal slot, then: *)
                  (* 26.3 (NOT SUPPORTED) Otherwise, if value is a platform object that is a serializable object, ... *)
                  (* 26.4 Otherwise, for each key in ! EnumerableOwnPropertyNames(value, key): *)
                  (* Step 26.4 is implemented in SerializeObject (defined above) *)
                  serializedObj := "SerializeObject"(xsc, vthis, value, forStorage, memory, datacloneerr, "Object") with elab;
                  serialized := [serializedObj, "serialized"];
                  objmem := [serializedObj, "memory"];
                  memory := objmem;
                  goto succ;     
    succ:         (* 27. Return serialized. *)
                  (*debugger;*)
                  res := new ();
                  [res, "serialized"] := serialized;
                  [res, "memory"] := memory;
                  ret := res;
                  return;
    elab:         throw
};

(* Serializes msg. Function follows PostMessage web standard *)
(*TODO: do we need 'forStorage'? it is only used for array buffers and we currently do not support*)
proc StructuredSerializeInternal(xsc, vthis, value, forStorage, datacloneerr){
                  (* 1. If memory was not supplied, let memory be an empty map. *)
                  memory := "JSILMap_create" ();
                  res := "StructuredSerializeInternalWithMemory" (xsc, vthis, value, forStorage, memory, datacloneerr, 0) with elab;
                  ret := [res, "serialized"];
                  goto succ;
    succ:         return;
    elab:         throw
                  
};

(***************************)
(******DESERIALIZATION******)
(***************************)

proc DeserializeTypeAndVal(xsc, vthis, serialized){
                tser := typeOf serialized;
                goto [(tser = List) and ((l-len (serialized)) > 1)] oklist elab;
    oklist:     typelist := l-nth (serialized, 0);
                vallist := l-nth (serialized, 1);
                ttype := typeOf typelist;
                valltype := typeOf vallist;
                goto [(ttype = List) and (valltype = List) and ((l-len (typelist)) > 1) and ((l-len (vallist)) > 1)] oktv elab;
    oktv:       type := l-nth (typelist, 1);
                val := l-nth (vallist, 1);
                ret := {{ type, val }};
                return;
    elab:       ret := "TypeError" ();
                throw
};

proc DeserializeObjectWithPrimVal (xsc, vthis, type, v){
                value := undefined;
                (* 6. Otherwise, if serialized.[[Type]] is "Boolean", then set value to a new Boolean object in 
                  targetRealm whose [[BooleanData]] internal slot value is serialized.[[BooleanData]]. *)
                goto [type = "Boolean"] bool nbool;
    bool:       value := "Boolean_construct" (xsc, vthis, v);
                goto succ;      
    nbool:      (* 7. Otherwise, if serialized.[[Type]] is "Number", then set value to a new Number object in 
                  targetRealm whose [[NumberData]] internal slot value is serialized.[[NumberData]]. *)
                goto [type = "Number"] num nnum;  
    num:        value := "Number_construct" (xsc, vthis, v);
                goto succ;
    nnum:       (* 8. (NOT SUPPORTED) Otherwise, if serialized.[[Type]] is "BigInt", then set value to a new BigInt object in ... *)
                (* 9. Otherwise, if serialized.[[Type]] is "String", then set value to a new String object in *)
                 (* targetRealm whose [[StringData]] internal slot value is serialized.[[StringData]]. *)
                goto [type = "String"] str nstr;
    str:        value := "String_construct" (xsc, vthis, v);
                goto succ;
    nstr:       (* 10. Otherwise, if serialized.[[Type]] is "Date", then set value to a new Date object in *)
                  (* targetRealm whose [[DateValue]] internal slot value is serialized.[[DateValue]]. *)
                goto [type = "Date"] date ndate;
    date:       value := "Date_construct" (xsc, vthis, v);
                goto succ;
    ndate:      (* 11. (NOT SUPPORTED) Otherwise, if serialized.[[Type]] is "RegExp", then set value to a new RegExp object in ... *)
                (* 12. (NOT SUPPORTED) Otherwise, if serialized.[[Type]] is "SharedArrayBuffer", then: *)
                (* 13. (NOT SUPPORTED) Otherwise, if serialized.[[Type]] is "ArrayBuffer", then set value to a new ArrayBuffer object in ... *)
                (* 14. (NOT SUPPORTED) Otherwise, if serialized.[[Type]] is "ArrayBufferView", then: *)
                (* 15. (NOT SUPPORTED) Otherwise, if serialized.[[Type]] is "Map", then: *)
                (* 16. (NOT SUPPORTED) Otherwise, if serialized.[[Type]] is "Set", then: *)
                goto succ;
    succ:       ret := value;
                return
};

proc DeserializeErrorProps(xsc, vthis, serialized){
                goto [(typeOf serialized = List) and ((l-len (serialized)) > 1)] sok elab;
    sok:        typel := l-nth (serialized,0);
                namel := l-nth (serialized, 1);
                msgl := l-nth (serialized, 2);
                goto [(typeOf typel = List) and (typeOf namel = List) and (typeOf msgl = List)] propsok elab;
    propsok:    type := l-nth (typel, 1);
                name := l-nth (namel, 1);
                msg := l-nth (msgl, 1);
                ret := {{ type, name, msg }};
                return;
    elab:       ret := "TypeError" ();
                throw 

};

proc DeserializeErrorObj(xsc, vthis, serialized){
                err := "DeserializeErrorProps" (xsc, vthis, serialized);
                type := l-nth (err, 0);
                name := l-nth (err, 1);
                (* 19.1 Let prototype be %Error.prototype%. *)
                prototype := $lerr_proto;
                (* 19.2 If serialized.[[Name]] is "EvalError", then set prototype to %EvalError.prototype%. *)
                goto [name = "EvalError"] evalerr nevalerr;
    evalerr:    prototype := $leerr_proto;
                goto cont;  
    nevalerr:   (* 19.3 If serialized.[[Name]] is "RangeError", then set prototype to %RangeError.prototype%. *)
                goto [name = "RangeError"] rangeerr nrangeerr;
    rangeerr:   prototype := $lrgerr_proto;
                goto cont;
    nrangeerr:  (* 19.4 If serialized.[[Name]] is "ReferenceError", then set prototype to %ReferenceError.prototype%. *)
                goto [name = "ReferenceError"] referr nreferr;
    referr:     prototype := $lrferr_proto;
                goto cont;
    nreferr:    (* 19.5 If serialized.[[Name]] is "SyntaxError", then set prototype to %SyntaxError.prototype%. *)
                goto [name = "SyntaxError"] serr nserr;
    serr:       prototype := $lserr_proto;
                goto cont;
    nserr:      (* 19.6 If serialized.[[Name]] is "TypeError", then set prototype to %TypeError.prototype%. *)
                goto [name = "TypeError"] terr nterr;
    terr:       prototype := $lterr_proto;
                goto cont;
    nterr:      (* 19.7 If serialized.[[Name]] is "URIError", then set prototype to %URIError.prototype%. *)
                goto [name = "URIError"] urierr cont;
    urierr:     prototype := $luerr_proto;
                goto cont;
    cont:       (* 19.8. Let message be serialized.[[Message]]. *)
                message := l-nth (err, 2);
                (* 19.9 Set value to ! ObjectCreate(prototype, « [[ErrorData]] »). *)
                value := "Object_create" (xsc, vthis, prototype);
                (* 19.10 Let messageDesc be *)
                  (* PropertyDescriptor{ [[Value]]: message, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }. *)
                (* Creating desc with 
                    1. enumerable: false
                    2. configurable: true
                    3. value: message
                    4. writable: true
                    5. get: empty (not specified)
                    6. set: empty (not specified) *)
                messageDesc := {{ "g", false, true, message, true, empty, empty }};
                (* 19.11 If message is not undefined, then perform ! OrdinaryDefineOwnProperty(value, "message", messageDesc). *)
                goto [not (message = undefined)] msgundef succ;
    msgundef:   x := "defineOwnProperty"(value, "message", messageDesc);
                goto succ;
    succ:       (* 19.12 (VAGUE) Any interesting accompanying data attached to serialized should be deserialized and attached to value. *)
                ret := value;
                return;
    elab:       throw
};

proc DeserializeObjectProperty(propval){      
                tpropval := typeOf propval;
                goto [(tpropval = List) and ((l-len (propval)) > 1)] pvok elab;
    pvok:       propl := l-nth (propval, 0);
                tpropl := typeOf propl;
                goto [(tpropl = List) and ((l-len (propl)) > 1)] plok elab;
    plok:       prop := l-nth (propl, 1);
                vall := l-nth (propval, 1);
                tvall := typeOf vall;
                goto [(tvall = List) and ((l-len (vall)) > 1)] vallok elab;
    vallok:     v := l-nth (vall, 1);
                ret := {{ prop, v }};
                return;
    elab:       ret := "TypeError" ();
                throw
};

proc DeserializeObject(xsc, vthis, id, value, props, memory, obj_memory){
                typeprops := typeOf props;
                goto [(typeprops = List) and ((l-len (props)) > 1)] valok elab;
    valok:      propslist := l-nth (props, 1);
                i := 0;
                n := l-len (propslist);
                goto [n = 0] noprops loop;
    noprops:    obj_memory := "JSILMap_add_or_replace" (obj_memory, id, value);
                goto end;
                (* 22.3.1 For each Record { [[Key]], [[Value]] } entry of serialized.[[Properties]]: *)
    loop:       goto [i < n] addprop end;
    addprop:    kvserialized := l-nth (propslist, i);
                kv := "DeserializeObjectProperty"(kvserialized);
                entrykey := l-nth (kv, 0);
                entryvalue := l-nth (kv, 1);
                (* 22.3.1.1 Let deserializedValue be ? StructuredDeserialize(entry.[[Value]], targetRealm, memory). *)
                deserializedValueObj := "StructuredDeserializeWithMemory"(xsc, vthis, entryvalue, memory, obj_memory);
                obj_memory := [deserializedValueObj, "memory"];
                deserializedValue := [deserializedValueObj, "deserialized"];
                (* 22.3.1.2 Let result be ! CreateDataProperty(value, entry.[[Key]], deserializedValue). *)
                result := "put" (value, entrykey, deserializedValue);
                obj_memory := "JSILMap_add_or_replace" (obj_memory, id, value);
                i := i+1;
                goto loop;
    end:        res := new ();
                [res, "deserialized"] := value;
                [res, "memory"] := obj_memory; 
                ret := res;
                return;
    elab:       ret := "TypeError" ();
                throw       
};

proc StructuredDeserializeWithMemory(xsc, vthis, serialized, memory, obj_memory){
                (* 2. If memory[serialized] exists, then return memory[serialized]. *)  
                cache := "JSILMap_find" (memory, serialized);
                goto [cache = null] notfound found;
    found:      ret := new ();
                [ret, "deserialized"] := cache;
                [ret, "memory"] := obj_memory;
                return;
    notfound:   (* 3. Let deep be false. *)
                deep := false;
                (* 4. Let value be an uninitialized value. *)
                value := undefined;
                (* 5. If serialized.[[Type]] is "primitive", then set value to serialized.[[Value]]. *)
                typeval := "DeserializeTypeAndVal" (xsc, vthis, serialized) with elab;
                type := l-nth (typeval, 0);
                v := l-nth (typeval, 1);
                goto [type = "primitive"] prim nprim;
    prim:       value := v;
                goto mem;
                (* Steps 6 - 16 are implemented in DeserializeObjectWithPrimVal (defined above) *)
    nprim:      value := "DeserializeObjectWithPrimVal" (xsc, vthis, type, v);
                (* 17. Otherwise, if serialized.[[Type]] is "Array", then: *)
                goto [type = "Array"] arr narr;
    arr:        (* (DONE INSIDE Array_construct) 17.1 Let outputProto be targetRealm.[[Intrinsics]].[[%Array.prototype%]]. *)
                (* 17.2 Set value to ! ArrayCreate(serialized.[[Length]], outputProto). *)
                lengthl := l-nth (serialized, 3);
                length := l-nth (lengthl, 1);
                value := "Array_construct" (xsc, vthis, length);
                (* 17.3 Set deep to true. *)
                deep := true;
    narr:       (* 18. Otherwise, if serialized.[[Type]] is "Object", then: *)
                goto [type = "Object"] obj nobj;
    obj:        (* 18.1 Set value to a new Object in targetRealm. *)
                value := "Object_construct" ();
                (* 18.2 Set deep to true. *)
                deep := true;
                goto mem;
    nobj:       (* 19. Otherwise, if serialized.[[Type]] is "Error", then: *)
                goto [type = "Error"] err nerr;
    err:        value := "DeserializeErrorObj" (xsc, vthis, serialized);
                goto mem;
    nerr:       (* 20. (NOT SUPPORTED) Otherwise: *)
                goto mem;
    mem:        (* 21. Set memory[serialized] to value. *)
                memory := "JSILMap_add" (memory, serialized, value);
                (* 22. If deep is true, then: *)
                goto [deep = true] deept succ;
    deept:      (* 22.1 (NOT SUPPORTED) If serialized.[[Type]] is "Map", then: *)
                (* 22.2 (NOT SUPPORTED) Otherwise, if serialized.[[Type]] is "Set", then: *)
                (* 22.3 Otherwise, if serialized.[[Type]] is "Array" or "Object", then: *)
                goto [(type = "Array") or (type = "Object")] arrobj narrobj;
    arrobj:     keys := l-nth(serialized, 1);
                ids := l-nth(serialized, 2);
                id := l-nth(ids, 1);
                cache := "JSILMap_find" (obj_memory, id);
                goto [cache = null] nullcache nnullcache;
    nnullcache: res := new ();
                [res, "deserialized"] := cache;
                [res, "memory"] := obj_memory;
                ret := res;
                return;
    nullcache:  valueObj := "DeserializeObject" (xsc, vthis, id, value, keys, memory, obj_memory) with elab;  
                value := [valueObj, "deserialized"];
                obj_memory := [valueObj, "memory"];
    narrobj:    (* 22.4 (NOT SUPPORTED) Otherwise: Perform the appropriate deserialization steps for the interface identified by *)
                  (* serialized.[[Type]], given serialized and value. *)
                goto succ;
    succ:       res := new ();
                [res, "deserialized"] := value;
                [res, "memory"] := obj_memory;
                ret := res;
                return;                
    elab:       ret := "TypeError" ();
                throw
};

(* Deserializes msg based on serialization algorithm; applies reverse transformation *)
proc StructuredDeserialize (xsc, vthis, serialized){
                (* 1. If memory was not supplied, let memory be an empty map. *)
                memory := "JSILMap_create" ();
                obj_memory := "JSILMap_create" ();
                (* The remaining steps are implemented in StructuredDeserializeWithMemory (defined above) *)
                deserializedObj := "StructuredDeserializeWithMemory" (xsc, vthis, serialized, memory, obj_memory) with elab;
    succ:       ret := [deserializedObj, "deserialized"];
                return;
    elab:       throw
};